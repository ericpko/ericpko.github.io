{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bio \u2693\ufe0e \u2003Hello! I'm a recent graduate from the University of Toronto St. George (downtown) campus with an HBSc in Computer Science . Throughout my studies I've acquired great problem solving skills and have gained experience with a variety of programming languages and software tools. The topics that I'm most passionate about include graphics , web development , and game design . I'm always excited to experiment with the latest and greatest tech stacks! Lately, I've been obsessed with the Rust Programming Language and I'm eager to learn more about WebAssembly. On a personal level, I'm a well-rounded individual who enjoys playing racket sports such as tennis, pickleball, badminton, and table tennis. I also enjoy paddleboarding, working out, and maintaining a healthy lifestyle. Courses \u2693\ufe0e CSC108: Introduction to Computer Programming (Python) MAT137: Calculus I (Full year) CSC148: Introduction to Computer Science (Python) CSC165: Mathematical Expression and Reasoning for Computer Science CSC207: Software Design (Java) CSC209: Software Tools and Systems Programming (C) MAT223: Linear Algebra I MAT235: Multivariable Calculus (Full year) CSC236: Theory of Computation MAT244: Ordinary Differential Equations PHL245: Modern Symbolic Logic STA247: Probability with Computer Applications CSC258: Computer Organization (Verilog) CSC263: Data Structures and Analysis CSC309: Programming on the Web (Javascript) CSC318: The Design of Interactive Computational Media CSC343: Databases (SQL) CSC367: Parallel Programming (C/C++) CSC369: Operating Systems (C) CSC373: Algorithm Design, Analysis & Complexity CSC384: Artificial Intelligence (Python) CSC404: Video Game Design (Unity/C#) CSC417: Physics-based Animation (C++) CSC418: Computer Graphics (C++) CSC419: Geometry Processing (C++)","title":"Home"},{"location":"#bio","text":"Hello! I'm a recent graduate from the University of Toronto St. George (downtown) campus with an HBSc in Computer Science . Throughout my studies I've acquired great problem solving skills and have gained experience with a variety of programming languages and software tools. The topics that I'm most passionate about include graphics , web development , and game design . I'm always excited to experiment with the latest and greatest tech stacks! Lately, I've been obsessed with the Rust Programming Language and I'm eager to learn more about WebAssembly. On a personal level, I'm a well-rounded individual who enjoys playing racket sports such as tennis, pickleball, badminton, and table tennis. I also enjoy paddleboarding, working out, and maintaining a healthy lifestyle.","title":"Bio"},{"location":"#courses","text":"CSC108: Introduction to Computer Programming (Python) MAT137: Calculus I (Full year) CSC148: Introduction to Computer Science (Python) CSC165: Mathematical Expression and Reasoning for Computer Science CSC207: Software Design (Java) CSC209: Software Tools and Systems Programming (C) MAT223: Linear Algebra I MAT235: Multivariable Calculus (Full year) CSC236: Theory of Computation MAT244: Ordinary Differential Equations PHL245: Modern Symbolic Logic STA247: Probability with Computer Applications CSC258: Computer Organization (Verilog) CSC263: Data Structures and Analysis CSC309: Programming on the Web (Javascript) CSC318: The Design of Interactive Computational Media CSC343: Databases (SQL) CSC367: Parallel Programming (C/C++) CSC369: Operating Systems (C) CSC373: Algorithm Design, Analysis & Complexity CSC384: Artificial Intelligence (Python) CSC404: Video Game Design (Unity/C#) CSC417: Physics-based Animation (C++) CSC418: Computer Graphics (C++) CSC419: Geometry Processing (C++)","title":"Courses"},{"location":"contact/","text":"Contact Info \u2693\ufe0e Emails \u2693\ufe0e erickoehli@gmail.com eric.koehli@alum.utoronto.ca Links \u2693\ufe0e Resume GitHub LinkedIn","title":"Contact"},{"location":"contact/#contact-info","text":"","title":"Contact Info"},{"location":"contact/#emails","text":"erickoehli@gmail.com eric.koehli@alum.utoronto.ca","title":"Emails"},{"location":"contact/#links","text":"Resume GitHub LinkedIn","title":"Links"},{"location":"loop/","text":"What is Loop? \u2693\ufe0e Well, it's kind of like my blog I guess, except anyone is welcome to add, (not that anyone will). It's meant to serve as a catalog of common for-loop patterns over anything from 1D arrays to \\(n\\) D arrays. For example, in image processing we often run into common cases where we may want to iterate over a 2D image and apply a convolution. Although there are numerous packages that do exactly this, it's still nice to see what's actually happening. Similarly, we may want to write a 2D image into a 1D array, or vice versa. Structure \u2693\ufe0e Each problem will consist of a short description of the problem, followed by a general solution written in pseudo code or Python and an explantion. Contribute \u2693\ufe0e Have a problem and solution you want to add? Great! Simply write it up using Markdown and \\(\\LaTeX\\) .","title":"What is Loop?"},{"location":"loop/#what-is-loop","text":"Well, it's kind of like my blog I guess, except anyone is welcome to add, (not that anyone will). It's meant to serve as a catalog of common for-loop patterns over anything from 1D arrays to \\(n\\) D arrays. For example, in image processing we often run into common cases where we may want to iterate over a 2D image and apply a convolution. Although there are numerous packages that do exactly this, it's still nice to see what's actually happening. Similarly, we may want to write a 2D image into a 1D array, or vice versa.","title":"What is Loop?"},{"location":"loop/#structure","text":"Each problem will consist of a short description of the problem, followed by a general solution written in pseudo code or Python and an explantion.","title":"Structure"},{"location":"loop/#contribute","text":"Have a problem and solution you want to add? Great! Simply write it up using Markdown and \\(\\LaTeX\\) .","title":"Contribute"},{"location":"loop/problems/matrices/looping-diagonally/","text":"Looping diagonally \u2693\ufe0e Suppose you're given a matrix \\(\\mathbf{A} \\in \\mathbb{R}^{m \\times n}\\) and you want to iterate diagonally starting from \\(a_{11}\\) down to \\(a_{mn}\\) . We'll assume in this example that we're starting from index \\((1, 1)\\) and we'll change that later to start from \\((0, 0)\\) . \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & \\dots & a_{1n} \\\\ a_{21} & a_{22} & \\dots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m1} & a_{m2} & \\dots & a_{mn} \\end{bmatrix} \\] So let's say we want to iterate \\(a_{11}, a_{21}, a_{12}, a_{31}, a_{22}, a_{13}, \\dots, a_{mn}\\) . Let's take a look at an example where \\(m = 5\\) and \\(n = 6\\) : \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & a_{13} & a_{14} & a_{15} & a_{16} \\\\ a_{21} & a_{22} & a_{23} & a_{24} & a_{25} & a_{26} \\\\ a_{31} & a_{32} & a_{33} & a_{34} & a_{35} & a_{36} \\\\ a_{41} & a_{42} & a_{43} & a_{44} & a_{45} & a_{46} \\\\ a_{51} & a_{52} & a_{53} & a_{54} & a_{55} & a_{56} \\end{bmatrix} \\] \\[\\begin{gathered} a_{11} \\\\ a_{21} a_{12} \\\\ a_{31} a_{22} a_{13} \\\\ a_{41} a_{32} a_{23} a_{14} \\\\ a_{51} a_{42} a_{33} a_{24} a_{15} \\\\ a_{52} a_{43} a_{34} a_{25} a_{16} \\\\ a_{53} a_{44} a_{35} a_{26} \\\\ a_{54} a_{45} a_{36} \\\\ a_{55} a_{46} \\\\ a_{56} \\end{gathered}\\] Notice a pattern? There's actually at least two patterns going on here: across each row of \\(a_{ij}\\) index \\(i\\) is decreasing and index \\(j\\) is increasing. Notice anything else? The sum of the indices across each row is constant! The smallest constant is when \\((i, j) = (1, 1)\\) is \\(2\\) and the largest constant is when \\((i, j) = (5, 6)\\) is \\(11\\) . Thus, we'll want an outter loop that tracks the index constant \\(k\\) for each row and stops when the constant \\(k >= 12\\) . Solution 1: Indices starting at (1, 1) \u2693\ufe0e for k in range ( 2 , m + n + 1 ): for j in range ( 1 , k ): i = k - j # Now we need to check the bounds because as the constant k grows # past m, that means i will be greater than m sometimes and j will # be greater than n sometimes. if i <= m and j <= n : # Safe to access A A [ i ][ j ] # ... Now let's take the previous example and assume that the indices start at \\((i, j) = (0, 0)\\) and end at \\((m - 1, n - 1)\\) . Then our smallest constant value is \\(k = 0\\) at \\((0, 0)\\) and the largest constant value is \\[\\begin{aligned} k &= m - 1 + n - 1 \\\\ &= m + n - 2 \\end{aligned}\\] Solution 2: Indices starting at (0, 0) \u2693\ufe0e for k in range ( m + n ): for j in range ( k + 1 ): i = k - j # Now we need to check the bounds if i < m and j < n : # Safe to access A A [ i ][ j ] # ... Now you may have noticed something subtle about these solutions: is it necessary to check the bounds? It's seems like we're doing more work than we need to after the constant \\(k\\) reaches the minimum of \\(m\\) and \\(n\\) because after this point, some of the indices will be out of bounds. There is a solution to the problem, one in which we don't need to check the index bounds, but the cost is that we have to split the loop into a top half and a bottom half. TODO finish this case . Starting from bottom left corner \u2693\ufe0e What if we wanted to loop through the matrix starting from the bottom left corner? That is, from \\((m, 1)\\) to \\((1, n)\\) : \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & a_{13} & a_{14} & a_{15} & a_{16} \\\\ a_{21} & a_{22} & a_{23} & a_{24} & a_{25} & a_{26} \\\\ a_{31} & a_{32} & a_{33} & a_{34} & a_{35} & a_{36} \\\\ a_{41} & a_{42} & a_{43} & a_{44} & a_{45} & a_{46} \\\\ a_{51} & a_{52} & a_{53} & a_{54} & a_{55} & a_{56} \\end{bmatrix} \\] Taking the previous example, let's see if we can find a pattern. \\[\\begin{gather} a_{51} \\\\ a_{41} a_{52} \\\\ a_{31} a_{42} a_{53} \\\\ a_{21} a_{32} a_{43} a_{54} \\\\ a_{11} a_{22} a_{33} a_{44} a_{55} \\\\ a_{12} a_{23} a_{34} a_{45} a_{56} \\\\ a_{13} a_{24} a_{35} a_{46} \\\\ a_{14} a_{25} a_{36} \\\\ a_{15} a_{26} \\\\ a_{16} \\end{gather}\\] In this case, our sum of indices \\(i + j\\) are no longer constant along each row. They do however increase by two as we move along a row. In any case, there is a clever solution we can use by adding just one line to our original solution and adding an extra bound check: Solution: Indices starting at (1, 1) \u2693\ufe0e for k in range ( 2 , m + n + 1 ): for j in range ( 1 , k ): i = k - j i = m + 1 - i # reflect i if i >= 0 and i <= m and j <= n : # Safe to access A A [ i ][ j ] # ...","title":"Looping Diagonally"},{"location":"loop/problems/matrices/looping-diagonally/#looping-diagonally","text":"Suppose you're given a matrix \\(\\mathbf{A} \\in \\mathbb{R}^{m \\times n}\\) and you want to iterate diagonally starting from \\(a_{11}\\) down to \\(a_{mn}\\) . We'll assume in this example that we're starting from index \\((1, 1)\\) and we'll change that later to start from \\((0, 0)\\) . \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & \\dots & a_{1n} \\\\ a_{21} & a_{22} & \\dots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m1} & a_{m2} & \\dots & a_{mn} \\end{bmatrix} \\] So let's say we want to iterate \\(a_{11}, a_{21}, a_{12}, a_{31}, a_{22}, a_{13}, \\dots, a_{mn}\\) . Let's take a look at an example where \\(m = 5\\) and \\(n = 6\\) : \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & a_{13} & a_{14} & a_{15} & a_{16} \\\\ a_{21} & a_{22} & a_{23} & a_{24} & a_{25} & a_{26} \\\\ a_{31} & a_{32} & a_{33} & a_{34} & a_{35} & a_{36} \\\\ a_{41} & a_{42} & a_{43} & a_{44} & a_{45} & a_{46} \\\\ a_{51} & a_{52} & a_{53} & a_{54} & a_{55} & a_{56} \\end{bmatrix} \\] \\[\\begin{gathered} a_{11} \\\\ a_{21} a_{12} \\\\ a_{31} a_{22} a_{13} \\\\ a_{41} a_{32} a_{23} a_{14} \\\\ a_{51} a_{42} a_{33} a_{24} a_{15} \\\\ a_{52} a_{43} a_{34} a_{25} a_{16} \\\\ a_{53} a_{44} a_{35} a_{26} \\\\ a_{54} a_{45} a_{36} \\\\ a_{55} a_{46} \\\\ a_{56} \\end{gathered}\\] Notice a pattern? There's actually at least two patterns going on here: across each row of \\(a_{ij}\\) index \\(i\\) is decreasing and index \\(j\\) is increasing. Notice anything else? The sum of the indices across each row is constant! The smallest constant is when \\((i, j) = (1, 1)\\) is \\(2\\) and the largest constant is when \\((i, j) = (5, 6)\\) is \\(11\\) . Thus, we'll want an outter loop that tracks the index constant \\(k\\) for each row and stops when the constant \\(k >= 12\\) .","title":"Looping diagonally"},{"location":"loop/problems/matrices/looping-diagonally/#solution-1-indices-starting-at-1-1","text":"for k in range ( 2 , m + n + 1 ): for j in range ( 1 , k ): i = k - j # Now we need to check the bounds because as the constant k grows # past m, that means i will be greater than m sometimes and j will # be greater than n sometimes. if i <= m and j <= n : # Safe to access A A [ i ][ j ] # ... Now let's take the previous example and assume that the indices start at \\((i, j) = (0, 0)\\) and end at \\((m - 1, n - 1)\\) . Then our smallest constant value is \\(k = 0\\) at \\((0, 0)\\) and the largest constant value is \\[\\begin{aligned} k &= m - 1 + n - 1 \\\\ &= m + n - 2 \\end{aligned}\\]","title":"Solution 1: Indices starting at (1, 1)"},{"location":"loop/problems/matrices/looping-diagonally/#solution-2-indices-starting-at-0-0","text":"for k in range ( m + n ): for j in range ( k + 1 ): i = k - j # Now we need to check the bounds if i < m and j < n : # Safe to access A A [ i ][ j ] # ... Now you may have noticed something subtle about these solutions: is it necessary to check the bounds? It's seems like we're doing more work than we need to after the constant \\(k\\) reaches the minimum of \\(m\\) and \\(n\\) because after this point, some of the indices will be out of bounds. There is a solution to the problem, one in which we don't need to check the index bounds, but the cost is that we have to split the loop into a top half and a bottom half. TODO finish this case .","title":"Solution 2: Indices starting at (0, 0)"},{"location":"loop/problems/matrices/looping-diagonally/#starting-from-bottom-left-corner","text":"What if we wanted to loop through the matrix starting from the bottom left corner? That is, from \\((m, 1)\\) to \\((1, n)\\) : \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & a_{13} & a_{14} & a_{15} & a_{16} \\\\ a_{21} & a_{22} & a_{23} & a_{24} & a_{25} & a_{26} \\\\ a_{31} & a_{32} & a_{33} & a_{34} & a_{35} & a_{36} \\\\ a_{41} & a_{42} & a_{43} & a_{44} & a_{45} & a_{46} \\\\ a_{51} & a_{52} & a_{53} & a_{54} & a_{55} & a_{56} \\end{bmatrix} \\] Taking the previous example, let's see if we can find a pattern. \\[\\begin{gather} a_{51} \\\\ a_{41} a_{52} \\\\ a_{31} a_{42} a_{53} \\\\ a_{21} a_{32} a_{43} a_{54} \\\\ a_{11} a_{22} a_{33} a_{44} a_{55} \\\\ a_{12} a_{23} a_{34} a_{45} a_{56} \\\\ a_{13} a_{24} a_{35} a_{46} \\\\ a_{14} a_{25} a_{36} \\\\ a_{15} a_{26} \\\\ a_{16} \\end{gather}\\] In this case, our sum of indices \\(i + j\\) are no longer constant along each row. They do however increase by two as we move along a row. In any case, there is a clever solution we can use by adding just one line to our original solution and adding an extra bound check:","title":"Starting from bottom left corner"},{"location":"loop/problems/matrices/looping-diagonally/#solution-indices-starting-at-1-1","text":"for k in range ( 2 , m + n + 1 ): for j in range ( 1 , k ): i = k - j i = m + 1 - i # reflect i if i >= 0 and i <= m and j <= n : # Safe to access A A [ i ][ j ] # ...","title":"Solution: Indices starting at (1, 1)"},{"location":"loop/problems/raster%20graphics/01-raster-images/","text":"What are raster images? \u2693\ufe0e Raster images \u2693\ufe0e A raster image is a 2D array or matrix that stores a pixel value for each pixel. If the image is colored, then each pixel is usually stored as a 3D vector of numbers that represent values for red, green, and blue. These rgb values are commonly referred to as subpixels . If the image is not colored, then each pixel stores a single value which controls the brightness of that pixel and the image is called grayscale. Where are the pixels in 2D space? \u2693\ufe0e This is an important question, but it's really just a matter of convention. For instance, some references count pixel positions \\((i, j)\\) starting from the upper left corner similar to a matrix: \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{bmatrix} \\] Reasons for this are historical and have to do with the way that rows in analog television transmissions started from the top left. In any case, we'll set our raster image inside a cartesian plane such that when we refer to pixel \\((i, j)\\) , we are saying that this pixel lives at column \\(i\\) and row \\(j\\) starting from the bottom left corner: Fundamentals of Computer Graphics, 4th edition In the image shown above, we can say that there are \\((n_x \\times n_y) = (4 \\times 3)\\) pixels.","title":"Raster Images"},{"location":"loop/problems/raster%20graphics/01-raster-images/#what-are-raster-images","text":"","title":"What are raster images?"},{"location":"loop/problems/raster%20graphics/01-raster-images/#raster-images","text":"A raster image is a 2D array or matrix that stores a pixel value for each pixel. If the image is colored, then each pixel is usually stored as a 3D vector of numbers that represent values for red, green, and blue. These rgb values are commonly referred to as subpixels . If the image is not colored, then each pixel stores a single value which controls the brightness of that pixel and the image is called grayscale.","title":"Raster images"},{"location":"loop/problems/raster%20graphics/01-raster-images/#where-are-the-pixels-in-2d-space","text":"This is an important question, but it's really just a matter of convention. For instance, some references count pixel positions \\((i, j)\\) starting from the upper left corner similar to a matrix: \\[ \\mathbf{A} = \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{bmatrix} \\] Reasons for this are historical and have to do with the way that rows in analog television transmissions started from the top left. In any case, we'll set our raster image inside a cartesian plane such that when we refer to pixel \\((i, j)\\) , we are saying that this pixel lives at column \\(i\\) and row \\(j\\) starting from the bottom left corner: Fundamentals of Computer Graphics, 4th edition In the image shown above, we can say that there are \\((n_x \\times n_y) = (4 \\times 3)\\) pixels.","title":"Where are the pixels in 2D space?"},{"location":"loop/problems/raster%20graphics/02-accessing-rgb/","text":"Accessing RBG values from a 1D image array \u2693\ufe0e Suppose you're given an image with \\(n_x\\) pixels wide and \\(n_y\\) pixels high. This image has dimensions \\(n_x \\times n_y\\) in pixels. Now suppose you're given a flattened (row-major ordered) 1D array img_1D containing this image and you want to access the individual rgb subpixels: for j in range ( n_y ): # for y in 0..height for i in range ( n_x ): # for x in 0..width r = img_1D [ 3 * ( j * n_x + i ) + 0 ] g = img_1D [ 3 * ( j * n_x + i ) + 1 ] b = img_1D [ 3 * ( j * n_x + i ) + 2 ] # ... # do stuff with rgb values # ... Before we break down that weird index, let's just describe how we're iterating over the image. Our outter loop is starting from \\(0\\) and increasing along the \\(y\\) axis and our inner loop is starting from \\(0\\) and increasing along the \\(x\\) axis. In other words, we're starting from the bottom left pixel of the image and moving across each row, then up one column and repeating. Now let's see what's happening with the index. We'll start with the number in brackets: \\((j * n_x + i)\\) . Imagine our 2D image in the cartesian plane and we're given pixel \\((i, j)\\) , which is at column \\(i\\) and row \\(j\\) . What we need is a mapping from the 2D image space to our 1D array space. Since our 2D image is flattened into a 1D array, and since we know our position \\((i, j)\\) in the 2D image, we can create a mapping \\(T\\) from \\(\\mathbb{R^2} \\rightarrow \\mathbb{R}\\) . Thus, we know at least two mappings: \\[ T \\left( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right) = T \\left( \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\right) = 1 \\] and \\[ T \\left( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right) = T \\left( \\begin{bmatrix} n_x - 1 \\\\ n_y - 1 \\end{bmatrix} \\right) = n_x n_y - 1 \\] This is just saying that \\((i, j) = (1, 0)\\) should be mapped to index \\(1\\) in the 1D array and \\((i, j) = (n_x - 1, n_y - 1)\\) should be mapped to the last index in the 1D array: \\(n_x n_y - 1\\) . Now our goal is to find a general formula for the mapping \\[ T \\left( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right) \\] Let's assume that \\(T(\\mathbf{x}) = \\mathbf{A} \\mathbf{x}\\) for all \\(\\mathbf{x} \\in \\mathbb{R^2}\\) . Now our goal can be rephrased to finding a matrix \\(\\mathbf{A}\\) , whose size we can infer will be \\(1 \\times 2\\) . So let's start by computing \\[\\begin{aligned} & \\mathbf{A} \\begin{bmatrix} 1 & n_x - 1 \\\\ 0 & n_y - 1 \\end{bmatrix} \\\\ &= \\begin{bmatrix} \\mathbf{A} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} & \\mathbf{A} \\begin{bmatrix} n_x - 1 \\\\ n_y - 1 \\end{bmatrix} \\end{bmatrix} \\\\ &= \\begin{bmatrix} T \\left( \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\right ) & T \\left( \\begin{bmatrix} n_x - 1 \\\\ n_y - 1 \\end{bmatrix} \\right) \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & n_x n_y - 1 \\end{bmatrix} \\end{aligned}\\] Now we find the inverse matrix of \\[ \\begin{bmatrix} 1 & n_x - 1 \\\\ 0 & n_y - 1 \\end{bmatrix}^{-1} = \\frac{1}{n_y - 1} \\begin{bmatrix} n_y - 1 & 1 - n_x \\\\ 0 & 1 \\end{bmatrix} \\] And now we can solve for \\(\\mathbf{A}\\) since we have \\(\\mathbf{A} \\mathbf{B} \\mathbf{B}^{-1} = \\mathbf{A} \\mathbf{I} = \\mathbf{A}\\) : \\[\\begin{aligned} \\mathbf{A} &= \\begin{bmatrix} 1 & n_x n_y - 1 \\end{bmatrix} \\begin{bmatrix} 1 & \\frac{1 - n_x}{n_y - 1} \\\\ 0 & \\frac{1}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & \\frac{1 - n_x}{n_y - 1} + \\frac{n_x n_y - 1}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & \\frac{n_x n_y - n_x}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & \\frac{n_x(n_y -1)}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & n_x \\end{bmatrix} \\end{aligned}\\] and this is exactly our linear transformation: \\[\\begin{aligned} T \\left ( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right ) &= \\mathbf{A} \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & n_x \\end{bmatrix} \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\\\ &= i + n_x j \\\\ &= j * n_x + i \\end{aligned}\\] This is of course extreme overkill for our simple problem, when intuitively we can just imagine that the \\(j * n_x\\) term shifts \\(j\\) times the width of the image upwards in the \\(y\\) axis, and the \\(i\\) term shifts us in the \\(x\\) direction. So now that we have our 2D to 1D mapping, we can follow the same logic to understand the other terms of our index: \\(3 * (j * n_x + i) + s\\) , where \\(s = 0, 1\\) or \\(2\\) . Since we know our image is colored and has rgb subpixel values, we need to shift our pixel index \\((j * n_x + i)\\) by \\(3\\) since each pixel has \\(3\\) subpixels. Then to access an individual subpixel, we need an offset of \\(0\\) to access red, \\(1\\) to access green, and \\(2\\) to access blue. Some image formats store an alpha \\(\\alpha\\) value which controls the opacity. Using our logic from above, it's easy to generalize to the case in which we wanted to access the alpha value from an rgba image: alpha = img_1D [ 4 * ( j * n_x + i ) + 3 ]","title":"Accessing RBG values from a 1D image array"},{"location":"loop/problems/raster%20graphics/02-accessing-rgb/#accessing-rbg-values-from-a-1d-image-array","text":"Suppose you're given an image with \\(n_x\\) pixels wide and \\(n_y\\) pixels high. This image has dimensions \\(n_x \\times n_y\\) in pixels. Now suppose you're given a flattened (row-major ordered) 1D array img_1D containing this image and you want to access the individual rgb subpixels: for j in range ( n_y ): # for y in 0..height for i in range ( n_x ): # for x in 0..width r = img_1D [ 3 * ( j * n_x + i ) + 0 ] g = img_1D [ 3 * ( j * n_x + i ) + 1 ] b = img_1D [ 3 * ( j * n_x + i ) + 2 ] # ... # do stuff with rgb values # ... Before we break down that weird index, let's just describe how we're iterating over the image. Our outter loop is starting from \\(0\\) and increasing along the \\(y\\) axis and our inner loop is starting from \\(0\\) and increasing along the \\(x\\) axis. In other words, we're starting from the bottom left pixel of the image and moving across each row, then up one column and repeating. Now let's see what's happening with the index. We'll start with the number in brackets: \\((j * n_x + i)\\) . Imagine our 2D image in the cartesian plane and we're given pixel \\((i, j)\\) , which is at column \\(i\\) and row \\(j\\) . What we need is a mapping from the 2D image space to our 1D array space. Since our 2D image is flattened into a 1D array, and since we know our position \\((i, j)\\) in the 2D image, we can create a mapping \\(T\\) from \\(\\mathbb{R^2} \\rightarrow \\mathbb{R}\\) . Thus, we know at least two mappings: \\[ T \\left( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right) = T \\left( \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\right) = 1 \\] and \\[ T \\left( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right) = T \\left( \\begin{bmatrix} n_x - 1 \\\\ n_y - 1 \\end{bmatrix} \\right) = n_x n_y - 1 \\] This is just saying that \\((i, j) = (1, 0)\\) should be mapped to index \\(1\\) in the 1D array and \\((i, j) = (n_x - 1, n_y - 1)\\) should be mapped to the last index in the 1D array: \\(n_x n_y - 1\\) . Now our goal is to find a general formula for the mapping \\[ T \\left( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right) \\] Let's assume that \\(T(\\mathbf{x}) = \\mathbf{A} \\mathbf{x}\\) for all \\(\\mathbf{x} \\in \\mathbb{R^2}\\) . Now our goal can be rephrased to finding a matrix \\(\\mathbf{A}\\) , whose size we can infer will be \\(1 \\times 2\\) . So let's start by computing \\[\\begin{aligned} & \\mathbf{A} \\begin{bmatrix} 1 & n_x - 1 \\\\ 0 & n_y - 1 \\end{bmatrix} \\\\ &= \\begin{bmatrix} \\mathbf{A} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} & \\mathbf{A} \\begin{bmatrix} n_x - 1 \\\\ n_y - 1 \\end{bmatrix} \\end{bmatrix} \\\\ &= \\begin{bmatrix} T \\left( \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\right ) & T \\left( \\begin{bmatrix} n_x - 1 \\\\ n_y - 1 \\end{bmatrix} \\right) \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & n_x n_y - 1 \\end{bmatrix} \\end{aligned}\\] Now we find the inverse matrix of \\[ \\begin{bmatrix} 1 & n_x - 1 \\\\ 0 & n_y - 1 \\end{bmatrix}^{-1} = \\frac{1}{n_y - 1} \\begin{bmatrix} n_y - 1 & 1 - n_x \\\\ 0 & 1 \\end{bmatrix} \\] And now we can solve for \\(\\mathbf{A}\\) since we have \\(\\mathbf{A} \\mathbf{B} \\mathbf{B}^{-1} = \\mathbf{A} \\mathbf{I} = \\mathbf{A}\\) : \\[\\begin{aligned} \\mathbf{A} &= \\begin{bmatrix} 1 & n_x n_y - 1 \\end{bmatrix} \\begin{bmatrix} 1 & \\frac{1 - n_x}{n_y - 1} \\\\ 0 & \\frac{1}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & \\frac{1 - n_x}{n_y - 1} + \\frac{n_x n_y - 1}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & \\frac{n_x n_y - n_x}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & \\frac{n_x(n_y -1)}{n_y - 1} \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & n_x \\end{bmatrix} \\end{aligned}\\] and this is exactly our linear transformation: \\[\\begin{aligned} T \\left ( \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\right ) &= \\mathbf{A} \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & n_x \\end{bmatrix} \\begin{bmatrix} i \\\\ j \\end{bmatrix} \\\\ &= i + n_x j \\\\ &= j * n_x + i \\end{aligned}\\] This is of course extreme overkill for our simple problem, when intuitively we can just imagine that the \\(j * n_x\\) term shifts \\(j\\) times the width of the image upwards in the \\(y\\) axis, and the \\(i\\) term shifts us in the \\(x\\) direction. So now that we have our 2D to 1D mapping, we can follow the same logic to understand the other terms of our index: \\(3 * (j * n_x + i) + s\\) , where \\(s = 0, 1\\) or \\(2\\) . Since we know our image is colored and has rgb subpixel values, we need to shift our pixel index \\((j * n_x + i)\\) by \\(3\\) since each pixel has \\(3\\) subpixels. Then to access an individual subpixel, we need an offset of \\(0\\) to access red, \\(1\\) to access green, and \\(2\\) to access blue. Some image formats store an alpha \\(\\alpha\\) value which controls the opacity. Using our logic from above, it's easy to generalize to the case in which we wanted to access the alpha value from an rgba image: alpha = img_1D [ 4 * ( j * n_x + i ) + 3 ]","title":"Accessing RBG values from a 1D image array"},{"location":"loop/problems/raster%20graphics/03-applying-convolution/","text":"Applying a convolution over a 2D image \u2693\ufe0e Suppose we're given a flattened 1D greyscale image img_1D with \\(n_x\\) pixels wide and \\(n_y\\) pixels high and a flattened 1D filter filter_1D with dimensions \\(f_n \\times f_n\\) that we want to apply to the image. Solution \u2693\ufe0e We'll first break this problem up into two functions: one will apply the convolution for a single pixel, and the other function will apply the filter for ever pixel over the entire image. We'll start by writing the outter function. def apply_filter2d ( img_1D : list , n_x : int , n_y : int , filter_1D : list , f_n : int ) -> list : filtered_img = [] # Iterate over each pixel (i, j) of the imaginary 2D image for j in range ( n_y ): for i in range ( n_x ): # get the pixel index pxl_idx = j * n_x + i # apply convolution to pixel (i, j) pxl_val = apply2d ( img_1D , n_x , n_y , filter_1D , f_n , i , j ) filtered_img [ pxl_idx ] = pxl_val # update min and max pixel value seen so far if you also want to normalize image # ... return filtered_img Now we just need to write the code for apply2d , which applies the filter to each pixel. def apply2d ( img_1D : list , n_x : int , n_y : int , filter_1D : list , f_n : int , i : int , j : int ) -> float : # Get the mid point of the filter dimension: f_mid = f_n // 2 pairwise_product = 0.0 # Iterate over the rows of the filter: for row in range ( f_n ): # Get the row offset for the original image: row_offset = f_mid - ( f_n - 1 ) + row # ranges between (-f_mid, f_mid + 1) # Iterate over the columns of the filter: for col in range ( f_n ): # Get the column offset for the original image: col_offset = f_mid - ( f_n - 1 ) + col # Get the new indices of the original image for boundary checking: x = i + col_offset y = j + row_offset # Check if the corresponding indices in the original image are in bound: if x >= 0 and x < n_x and y >= 0 and y < n_y : # Convert the 2D indices to 1D pxl_idx = y * n_x + x flt_idx = row * f_n + col # Sum the pairwise product: pairwise_product += img_1D [ pxl_idx ] * filter_1D [ flt_idx ] return int ( pairwise_product )","title":"Applying a convolution over a 2D image"},{"location":"loop/problems/raster%20graphics/03-applying-convolution/#applying-a-convolution-over-a-2d-image","text":"Suppose we're given a flattened 1D greyscale image img_1D with \\(n_x\\) pixels wide and \\(n_y\\) pixels high and a flattened 1D filter filter_1D with dimensions \\(f_n \\times f_n\\) that we want to apply to the image.","title":"Applying a convolution over a 2D image"},{"location":"loop/problems/raster%20graphics/03-applying-convolution/#solution","text":"We'll first break this problem up into two functions: one will apply the convolution for a single pixel, and the other function will apply the filter for ever pixel over the entire image. We'll start by writing the outter function. def apply_filter2d ( img_1D : list , n_x : int , n_y : int , filter_1D : list , f_n : int ) -> list : filtered_img = [] # Iterate over each pixel (i, j) of the imaginary 2D image for j in range ( n_y ): for i in range ( n_x ): # get the pixel index pxl_idx = j * n_x + i # apply convolution to pixel (i, j) pxl_val = apply2d ( img_1D , n_x , n_y , filter_1D , f_n , i , j ) filtered_img [ pxl_idx ] = pxl_val # update min and max pixel value seen so far if you also want to normalize image # ... return filtered_img Now we just need to write the code for apply2d , which applies the filter to each pixel. def apply2d ( img_1D : list , n_x : int , n_y : int , filter_1D : list , f_n : int , i : int , j : int ) -> float : # Get the mid point of the filter dimension: f_mid = f_n // 2 pairwise_product = 0.0 # Iterate over the rows of the filter: for row in range ( f_n ): # Get the row offset for the original image: row_offset = f_mid - ( f_n - 1 ) + row # ranges between (-f_mid, f_mid + 1) # Iterate over the columns of the filter: for col in range ( f_n ): # Get the column offset for the original image: col_offset = f_mid - ( f_n - 1 ) + col # Get the new indices of the original image for boundary checking: x = i + col_offset y = j + row_offset # Check if the corresponding indices in the original image are in bound: if x >= 0 and x < n_x and y >= 0 and y < n_y : # Convert the 2D indices to 1D pxl_idx = y * n_x + x flt_idx = row * f_n + col # Sum the pairwise product: pairwise_product += img_1D [ pxl_idx ] * filter_1D [ flt_idx ] return int ( pairwise_product )","title":"Solution"},{"location":"projects/a-weathery-journey/","text":"A Weathery Journey \u2693\ufe0e This is a 3D puzzle-platformer where you play as a wizard that has the power to manipulate the weather around him. You use his abilities\u2014sun, wind, rain, and snow\u2014to solve puzzles and platform your way across the levels! This was a really fun project where I had the pleasure of working with a small team of developers, artists, and musicians from the University of Toronto , and OCAD University . Website: A Weathery Journey","title":"A Weathery Journey"},{"location":"projects/a-weathery-journey/#a-weathery-journey","text":"This is a 3D puzzle-platformer where you play as a wizard that has the power to manipulate the weather around him. You use his abilities\u2014sun, wind, rain, and snow\u2014to solve puzzles and platform your way across the levels! This was a really fun project where I had the pleasure of working with a small team of developers, artists, and musicians from the University of Toronto , and OCAD University . Website: A Weathery Journey","title":"A Weathery Journey"},{"location":"projects/billard-balls/","text":"Billard Balls \u2693\ufe0e Some simple billard ball collisions using the Bevy Game Engine .","title":"Billard Balls"},{"location":"projects/billard-balls/#billard-balls","text":"Some simple billard ball collisions using the Bevy Game Engine .","title":"Billard Balls"},{"location":"projects/boids/","text":"Boids \u2693\ufe0e These are some boids I made in Rust using the ggez game library. I followed this pseudocode guide","title":"Boids"},{"location":"projects/boids/#boids","text":"These are some boids I made in Rust using the ggez game library. I followed this pseudocode guide","title":"Boids"},{"location":"projects/ray-tracer/","text":"Ray Tracer \u2693\ufe0e I built this ray tracer entirely in Rust as a way to learn Rust . Here are some of the rendered images:","title":"Ray Tracer"},{"location":"projects/ray-tracer/#ray-tracer","text":"I built this ray tracer entirely in Rust as a way to learn Rust . Here are some of the rendered images:","title":"Ray Tracer"},{"location":"projects/sph-sim/","text":"2D Smoothed Particle Hydrodynamics \u2693\ufe0e This was a fun final project that I chose for my physics-based animation course at UofT. Check out my SIGGRAPH Technical Brief here where you can find the in-depth details from this project. Below I've provided a simulation demo of the results written in MATLAB. I've recently re-implmented this project in Rust using the ggez game library.","title":"2D Smoothed Particle Hydrodynamics"},{"location":"projects/sph-sim/#2d-smoothed-particle-hydrodynamics","text":"This was a fun final project that I chose for my physics-based animation course at UofT. Check out my SIGGRAPH Technical Brief here where you can find the in-depth details from this project. Below I've provided a simulation demo of the results written in MATLAB. I've recently re-implmented this project in Rust using the ggez game library.","title":"2D Smoothed Particle Hydrodynamics"}]}